\section{compilation/translation model for JavaScript and each of its variants}
\subsection{compilation/translation model for JavaScript}
JavaScript is both a dynamically typed and interpreted language. This means that it has no compilation step like Java, C++ and other similar languages. To run JavaScript, an interpreter in the browser reads over the code and interprets each line and runs it. Some modern browsers use Just-In-Time compilers which compiles JavaScript to bytecode just as it is about to run.
\paragraph{}
The compilation process for JavaScript involves Lexing, Parsing and Code generation. Lexing takes in the code characters/strings to produce token objects. These tokens are taken by the parser which generates an abstract syntax tree. During the code generation step, the abstract syntax tree is traversed to produce the needed code\cite{jss}.
\subsection{compilation/translation model for Babeljs}
In 2015 the ECMAScript 6(ECMAScript 2015) specification was released for JavaScript. This new specification would change how developers write JavaScript. It introduced new keywords like 'const', 'let' and brought about classes to JavaScript. Some of the life changing features were arrow functions. As with all new standards in programming languages, it was loved by a few and hated by some. Those who hated the new features were part of the people with large code bases written in the old standards. 
\paragraph{}
To solve this, Babeljs was born. According to the documentation on the official website, Babeljs is defined as a toolchain that is used to convert ECMAScript 2015+(ES6) code into backwards compatible version of JavaScript\cite{babel}. Babeljs transforms most of the new syntactic sugar in ES6 into the old backward compatible syntax. As a compiler, Babel has three components which are: Parser, Transformer and the Generator. The parser takes in a stream of characters and turns them into a token object. The transformer takes the token object and converts it to an abstract syntax tree. The abstract syntax tree(AST) is fed into the Generator which then generates code\cite{babeltalk}.
\subsection{compilation/translation model for TypeScript}
TypeScript, a superset of a stricter version of JavaScript is used to achieve static typing in JavaScript. The compilation process for TypeScript begins with preprocessing. The preprocessor has to figure out what files should be included in the compilation process first. The parser then generates AST nodes from the code. This then followed by a binding process where the binder traverse the AST nodes, generates and binds symbols. The binder also ensures that generated symbols are created in the correct enclosing scope.
\paragraph{}
After the binding process, a sourceFile is generated by invoking the createSourceFile API. From the sourceFile, a program is created by calling the createProgram API which builds source files into a program. The program is the used to create an instance of the TypeChecker. The TypeChecker is the core of the TypeScript system since it is used to decipher the relationship between symbols from different files. An emitter can also be generated from the program. The  emitter is used to generate .js and .jsx files \cite{typescript}.

\subsection{compilation/translation model for CoffeeScript}
CoffeScript is a JavaScript variant that allows users to write simple and clean code which is then converted to its JavaScript equivalent. The first part of translation involves a lexer which takes in a stream of characters and converts it to token objects. From the token objects an AST is generated which is later converted to JavaScript code in the code generation stage.


